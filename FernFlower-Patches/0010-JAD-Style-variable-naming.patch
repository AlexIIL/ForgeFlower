From 3b1c9cfe16459485622dba642e5c8053d3a0005d Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Tue, 11 Apr 2017 22:37:40 -0700
Subject: [PATCH] JAD Style variable naming


diff --git a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
index 39619ce..36c08c4 100644
--- a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
+++ b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
@@ -21,8 +21,10 @@ import org.jetbrains.java.decompiler.main.collectors.ImportCollector;
 import org.jetbrains.java.decompiler.main.collectors.VarNamesCollector;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
 import org.jetbrains.java.decompiler.modules.renamer.PoolInterceptor;
 import org.jetbrains.java.decompiler.struct.StructContext;
+import org.jetbrains.java.decompiler.util.JADNameProvider;
 
 import java.util.HashMap;
 import java.util.Locale;
@@ -34,6 +36,7 @@ public class DecompilerContext {
   public static final String CURRENT_CLASS_NODE = "CURRENT_CLASS_NODE";
   public static final String CURRENT_METHOD_WRAPPER = "CURRENT_METHOD_WRAPPER";
   public static final String CURRENT_VAR_PROCESSOR = "CURRENT_VAR_PROCESSOR";
+  public static final String RENAMER_FACTORY = "RENAMER_FACTORY";
 
   private static final ThreadLocal<DecompilerContext> currentContext = new ThreadLocal<>();
 
@@ -46,17 +49,34 @@ public class DecompilerContext {
   private PoolInterceptor poolInterceptor;
   private IFernflowerLogger logger;
   private BytecodeSourceMapper bytecodeSourceMapper;
+  private IVariableNamingFactory renamerFactory;
 
   private DecompilerContext(Map<String, Object> properties) {
     this.properties = properties;
   }
 
-  public static void initContext(Map<String, Object> propertiesCustom) {
+  public static void initContext(Map<String, Object> propertiesCustom, IFernflowerLogger logger) {
     Map<String, Object> properties = new HashMap<>(IFernflowerPreferences.DEFAULTS);
     if (propertiesCustom != null) {
       properties.putAll(propertiesCustom);
     }
     currentContext.set(new DecompilerContext(properties));
+    setLogger(logger);
+    if (DecompilerContext.getProperty(RENAMER_FACTORY) != null) {
+      try {
+        currentContext.get().renamerFactory = Class.forName((String) DecompilerContext.getProperty(RENAMER_FACTORY)).asSubclass(IVariableNamingFactory.class).newInstance();
+      } catch (Exception e) {
+        if (getLogger() != null)
+          getLogger().writeMessage("Error loading renamer factory class", e);
+      }
+    }
+    if (DecompilerContext.getNamingFactory() == null) {
+      if (DecompilerContext.getOption(IFernflowerPreferences.USE_JAD_VARNAMING)) {
+        currentContext.get().renamerFactory = new JADNameProvider.JADNameProviderFactory();
+      } else {
+        currentContext.get().renamerFactory = new IdentityRenamerFactory();
+      }
+    }
   }
 
   public static DecompilerContext getCurrentContext() {
@@ -139,6 +159,10 @@ public class DecompilerContext {
     return getCurrentContext().logger;
   }
 
+  public static IVariableNamingFactory getNamingFactory() {
+    return getCurrentContext().renamerFactory;
+  }
+
   public static void setLogger(IFernflowerLogger logger) {
     if (logger != null) {
       String level = (String)getProperty(IFernflowerPreferences.LOG_LEVEL);
@@ -156,4 +180,4 @@ public class DecompilerContext {
     return getOption(IFernflowerPreferences.NEW_LINE_SEPARATOR) ?
            IFernflowerPreferences.LINE_SEPARATOR_UNX : IFernflowerPreferences.LINE_SEPARATOR_WIN;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/Fernflower.java b/src/org/jetbrains/java/decompiler/main/Fernflower.java
index e355ee9..1ba715c 100644
--- a/src/org/jetbrains/java/decompiler/main/Fernflower.java
+++ b/src/org/jetbrains/java/decompiler/main/Fernflower.java
@@ -36,9 +36,8 @@ public class Fernflower implements IDecompiledData {
 
   public Fernflower(IBytecodeProvider provider, IResultSaver saver, Map<String, Object> options, IFernflowerLogger logger) {
     structContext = new StructContext(saver, this, new LazyLoader(provider));
-    DecompilerContext.initContext(options);
+    DecompilerContext.initContext(options, logger);
     DecompilerContext.setCounterContainer(new CounterContainer());
-    DecompilerContext.setLogger(logger);
   }
 
   public void decompileContext() {
diff --git a/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java b/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java
new file mode 100644
index 0000000..a2ab00b
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/IdentityRenamerFactory.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.main;
+
+import java.util.Map;
+
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public class IdentityRenamerFactory implements IVariableNamingFactory, IVariableNameProvider {
+  @Override
+  public IVariableNameProvider createFactory(StructMethod method) {
+    return this;
+  }
+
+  @Override
+  public String renameAbstractParameter(String abstractParam, int index) {
+    return abstractParam;
+  }
+
+  @Override
+  public Map<VarVersionPair, String> rename(Map<VarVersionPair, String> variables) {
+    return null;
+  }
+  @Override
+  public void addParentContext(IVariableNameProvider renamer) {
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
index c1ceecd..a33978d 100644
--- a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
+++ b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
@@ -59,6 +59,8 @@ public interface IFernflowerPreferences {
   String LINE_SEPARATOR_WIN = "\r\n";
   String LINE_SEPARATOR_UNX = "\n";
 
+  String USE_JAD_VARNAMING = "jvn";
+
   Map<String, Object> DEFAULTS = getDefaults();
 
   static Map<String, Object> getDefaults() {
@@ -95,7 +97,8 @@ public interface IFernflowerPreferences {
     defaults.put(BANNER, "");
     defaults.put(UNIT_TEST_MODE, "0");
     defaults.put(DUMP_ORIGINAL_LINES, "0");
+    defaults.put(USE_JAD_VARNAMING, "0");
 
     return Collections.unmodifiableMap(defaults);
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java b/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java
new file mode 100644
index 0000000..8e6ab2b
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/extern/IVariableNameProvider.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.main.extern;
+
+import java.util.Map;
+
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+
+public interface IVariableNameProvider {
+  public Map<VarVersionPair,String> rename(Map<VarVersionPair,String> variables);
+  public String renameAbstractParameter(String abstractParam, int index);
+  public void addParentContext(IVariableNameProvider renamer);
+}
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java b/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java
new file mode 100644
index 0000000..fc1d7d6
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/main/extern/IVariableNamingFactory.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.main.extern;
+
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public interface IVariableNamingFactory {
+  public IVariableNameProvider createFactory(StructMethod structMethod);
+}
diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index ab2851e..627ab94 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -114,9 +114,9 @@ public class NestedClassProcessor {
     final MethodDescriptor md_content = MethodDescriptor.parseDescriptor(child.lambdaInformation.content_method_descriptor);
 
     final int vars_count = md_content.params.length - md_lambda.params.length;
-    //		if(vars_count < 0) { // should not happen, but just in case...
-    //			vars_count = 0;
-    //		}
+    //        if(vars_count < 0) { // should not happen, but just in case...
+    //            vars_count = 0;
+    //        }
 
     final boolean is_static_lambda_content = child.lambdaInformation.is_content_method_static;
 
@@ -427,6 +427,10 @@ public class NestedClassProcessor {
         Map<VarVersionPair, String> mapNewNames = new HashMap<>();  // local var names
         Map<VarVersionPair, VarType> mapNewTypes = new HashMap<>();  // local var types
 
+        if (enclosingMethod != null) {
+          method.methodStruct.getVariableNamer().addParentContext(enclosingMethod.methodStruct.getVariableNamer());
+        }
+
         final Map<Integer, VarVersionPair> mapParamsToNewVars = new HashMap<>();
         if (method.signatureFields != null) {
           int index = 0, varIndex = 1;
@@ -569,7 +573,7 @@ public class NestedClassProcessor {
               String key = InterpreterUtil.makeUniqueKey(fExpr.getClassname(), fExpr.getName(), fExpr.getDescriptor().descriptorString);
               if (mapFieldsToNewVars.containsKey(key)) {
                 //if(fExpr.getClassname().equals(child.classStruct.qualifiedName) &&
-                //		mapFieldsToNewVars.containsKey(key)) {
+                //        mapFieldsToNewVars.containsKey(key)) {
                 VarVersionPair newVar = mapFieldsToNewVars.get(key);
                 method.varproc.getExternalVars().add(newVar);
                 return new VarExprent(newVar.var, method.varproc.getVarType(newVar), method.varproc);
diff --git a/src/org/jetbrains/java/decompiler/struct/StructMethod.java b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
index d398c5e..c63a72e 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMethod.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
@@ -16,6 +16,8 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.*;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
@@ -54,6 +56,7 @@ public class StructMethod extends StructMember {
   private InstructionSequence seq;
   private boolean expanded = false;
   private VBStyleCollection<StructGeneralAttribute, String> codeAttributes;
+  private final IVariableNameProvider renamer;
 
   public StructMethod(DataInputFullStream in, StructClass clStruct) throws IOException {
     classStruct = clStruct;
@@ -72,6 +75,7 @@ public class StructMethod extends StructMember {
       attributes.addAllWithKey(codeAttributes);
       codeAttributes = null;
     }
+    this.renamer = DecompilerContext.getNamingFactory().createFactory(this);
   }
 
   @Override
@@ -390,6 +394,10 @@ public class StructMethod extends StructMember {
     return seq;
   }
 
+  public IVariableNameProvider getVariableNamer() {
+    return renamer;
+  }
+
   public StructLocalVariableTableAttribute getLocalVariableAttr() {
     return (StructLocalVariableTableAttribute)getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE);
   }
@@ -398,4 +406,4 @@ public class StructMethod extends StructMember {
   public String toString() {
     return name;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/util/JADNameProvider.java b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
new file mode 100644
index 0000000..d5bd964
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/JADNameProvider.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler.util;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+import org.jetbrains.java.decompiler.main.extern.IVariableNameProvider;
+import org.jetbrains.java.decompiler.main.extern.IVariableNamingFactory;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+
+public class JADNameProvider implements IVariableNameProvider {
+    private HashMap<String, Holder> last = null;
+    private HashMap<String, String> remap = null;
+    private static final Pattern CAPS_START = Pattern.compile("^[A-Z]");
+    private static final Pattern ARRAY = Pattern.compile("(\\[|\\.\\.\\.)");
+
+    public JADNameProvider(StructMethod wrapper) {
+      last = new HashMap<String, Holder>();
+      last.put("int",     new Holder(0, true,  "i", "j", "k", "l"));
+      last.put("byte",    new Holder(0, false, "b"       ));
+      last.put("char",    new Holder(0, false, "c"       ));
+      last.put("short",   new Holder(1, false, "short"   ));
+      last.put("boolean", new Holder(0, true,  "flag"    ));
+      last.put("double",  new Holder(0, false, "d"       ));
+      last.put("float",   new Holder(0, true,  "f"       ));
+      last.put("File",    new Holder(1, true,  "file"    ));
+      last.put("String",  new Holder(0, true,  "s"       ));
+      last.put("Class",   new Holder(0, true,  "oclass"  ));
+      last.put("Long",    new Holder(0, true,  "olong"   ));
+      last.put("Byte",    new Holder(0, true,  "obyte"   ));
+      last.put("Short",   new Holder(0, true,  "oshort"  ));
+      last.put("Boolean", new Holder(0, true,  "obool"   ));
+      last.put("Package", new Holder(0, true,  "opackage"));
+      last.put("Enum",    new Holder(0, true,  "oenum"   ));
+
+      remap = new HashMap<String, String>();
+      remap.put("long", "int");
+    }
+
+    @Override
+    public void addParentContext(IVariableNameProvider iparent) {
+        JADNameProvider parent = (JADNameProvider) iparent;
+        last = new HashMap<String, Holder>();
+        for (Entry<String, Holder> e : parent.last.entrySet()) {
+            Holder v = e.getValue();
+            last.put(e.getKey(), new Holder(v.id, v.skip_zero, v.names));
+        }
+
+        remap = new HashMap<String, String>();
+        for (Entry<String, String> e : parent.remap.entrySet()) {
+            remap.put(e.getKey(), e.getValue());
+        }
+    }
+
+    private static class Holder {
+      public int id;
+      public boolean skip_zero;
+      public final List<String> names = new ArrayList<String>();
+
+      public Holder(int t1, boolean skip_zero, String... names) {
+        this.id = t1;
+        this.skip_zero = skip_zero;
+        Collections.addAll(this.names, names);
+      }
+
+      public Holder(int t1, boolean skip_zero, List<String> names) {
+        this.id = t1;
+        this.skip_zero = skip_zero;
+        this.names.addAll(names);
+      }
+    }
+
+    public Map<VarVersionPair,String> rename(Map<VarVersionPair, String> entries) {
+      List<VarVersionPair> keys = new ArrayList<VarVersionPair>(entries.keySet());
+      Collections.sort(keys, new Comparator<VarVersionPair>(){
+        @Override
+        public int compare(VarVersionPair o1, VarVersionPair o2) {
+          if (o1.var != o2.var) return o1.var - o2.var;
+          return o1.version - o2.version;
+        }
+      });
+      Map<VarVersionPair,String> result = new LinkedHashMap<VarVersionPair,String>();
+      for (VarVersionPair ver : keys) {
+        String type = entries.get(ver);
+        if ("this".equals(type)) {
+          continue;
+        }
+        if (type.indexOf('<') != -1) {
+          type = type.substring(0, type.indexOf('<'));
+        }
+        if (type.indexOf('.') != -1) {
+          type = type.substring(type.lastIndexOf('.')+1);
+        }
+        result.put(ver, getNewName(type));
+      }
+      return result;
+    }
+
+    protected String getNewName(String type) {
+        String index = null;
+        String findtype = type;
+
+        while (findtype.contains("[][]"))
+        {
+            findtype = findtype.replaceAll("\\[\\]\\[\\]", "[]");
+        }
+        if (last.containsKey(findtype))
+        {
+            index = findtype;
+        }
+        else if (last.containsKey(findtype.toLowerCase(Locale.ENGLISH)))
+        {
+            index = findtype.toLowerCase(Locale.ENGLISH);
+        }
+        else if (remap.containsKey(type))
+        {
+            index = remap.get(type);
+        }
+
+        if ((index == null || index.length() == 0) && (CAPS_START.matcher(type).find() || ARRAY.matcher(type).find()))
+        {
+            // replace multi things with arrays.
+            type = type.replace("...", "[]");
+
+            while (type.contains("[][]"))
+            {
+                type = type.replaceAll("\\[\\]\\[\\]", "[]");
+            }
+
+            String name = type.toLowerCase(Locale.ENGLISH);
+            // Strip single dots that might happen because of inner class references
+            name = name.replace(".", "");
+            boolean skip_zero = true;
+
+            if (Pattern.compile("\\[").matcher(type).find())
+            {
+                skip_zero = true;
+                name = "a" + name;
+                name = name.replace("[]", "").replace("...", "");
+            }
+
+            last.put(type.toLowerCase(Locale.ENGLISH), new Holder(0, skip_zero, name));
+            index = type.toLowerCase(Locale.ENGLISH);
+        }
+
+        if (index == null || index.length() == 0)
+        {
+            return type.toLowerCase(Locale.ENGLISH);
+        }
+
+        Holder holder = last.get(index);
+        int id = holder.id;
+        List<String> names = holder.names;
+
+        int ammount = names.size();
+
+        String name;
+        if (ammount == 1)
+        {
+            name = names.get(0) + (id == 0 && holder.skip_zero ? "" : id);
+        }
+        else
+        {
+            int num = id / ammount;
+            name = names.get(id % ammount) + (id < ammount && holder.skip_zero ? "" : num);
+        }
+
+        holder.id++;
+        return name;
+    }
+
+    @Override
+    public String renameAbstractParameter(String abstractParam, int index) {
+      return abstractParam;
+    }
+
+
+    public static class JADNameProviderFactory implements IVariableNamingFactory {
+        @Override
+        public IVariableNameProvider createFactory(StructMethod method) {
+            return new JADNameProvider(method);
+        }
+
+    }
+}
diff --git a/test/org/jetbrains/java/decompiler/JADTest.java b/test/org/jetbrains/java/decompiler/JADTest.java
new file mode 100644
index 0000000..176b850
--- /dev/null
+++ b/test/org/jetbrains/java/decompiler/JADTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.java.decompiler;
+
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.junit.Test;
+
+public class JADTest extends SingleClassesTestBase {
+
+    @Override
+    protected String[] getDecompilerOptions() {
+      return new String[] {
+        IFernflowerPreferences.BYTECODE_SOURCE_MAPPING, "1",
+        IFernflowerPreferences.DUMP_ORIGINAL_LINES, "1",
+        IFernflowerPreferences.USE_JAD_VARNAMING, "1"
+      };
+    }
+
+    @Test public void testClassFields() { doTest("pkg/TestJADNaming"); }
+
+}
diff --git a/testData/classes/pkg/TestJADNaming.class b/testData/classes/pkg/TestJADNaming.class
new file mode 100644
index 0000000000000000000000000000000000000000..ce5676d7c337af79875dd42852333b71b071644c
GIT binary patch
literal 379
zcmY+8J5Iwu5QhJ?*Iqvo93vSCkrYq`3fv&mgh&XK0zoJe(XWkVIS(faHdo*n$rY$T
z6dZtxV{i(>*g;54F^~VB{dPXS-`)Y7pkYBpU0_SVVbD8imgZdswS9QUz%OR^F@tlR
zW^uomhVf!3!wD(8S7Z@GeUQs&d?V+TOb`ZZFe?^O+)K-~?P2_oU!7m}<uuKb<B@!n
zHE?JQ?tGm1|6GPf>H8CzCH`$VilZF+Q0Tfc6ws&8DC;z}s4}YB(F@o!H4K8Xz7Z)K
zf2&XQ)FkiJRlho}_&js%*RJcV0>0N=!fbhb1(gSy8t6O_YG8Ppr!Qf7!ZXMz;YtPH
nAtb1C3Em`R8x{iC75o6onnX>&Vidp{yD)#JjY3D+6|43GV%Iy?

literal 0
HcmV?d00001

diff --git a/testData/results/TestJADNaming.dec b/testData/results/TestJADNaming.dec
new file mode 100644
index 0000000..05ad201
--- /dev/null
+++ b/testData/results/TestJADNaming.dec
@@ -0,0 +1,81 @@
+package pkg;
+
+public class TestJADNaming {
+   public void Func() {
+      short var1 = 1000;// 7
+      short var2 = 2000;
+      short var3 = 3000;
+      short var4 = 4000;
+      if (var1 != var2 && var3 == var4) {// 8
+         ;
+      }
+
+      boolean var5 = true;// 9
+      boolean var6 = false;
+      boolean var7 = true;
+      boolean var8 = false;
+      if (var5 != var6 && var7 == var8) {// 10
+         ;
+      }
+
+   }// 11
+}
+
+class 'pkg/TestJADNaming' {
+   method 'Func ()V' {
+      0      4
+      1      4
+      2      4
+      3      4
+      4      5
+      5      5
+      6      5
+      7      5
+      8      6
+      9      6
+      a      6
+      b      6
+      c      7
+      d      7
+      e      7
+      f      7
+      10      7
+      11      8
+      12      8
+      13      8
+      16      8
+      17      8
+      18      8
+      19      8
+      1c      12
+      1d      12
+      1e      12
+      1f      13
+      20      13
+      21      13
+      22      14
+      23      14
+      24      14
+      25      15
+      26      15
+      27      15
+      28      16
+      29      16
+      2a      16
+      2b      16
+      2c      16
+      2f      16
+      30      16
+      31      16
+      32      16
+      33      16
+      36      20
+   }
+}
+
+Lines mapping:
+7 <-> 5
+8 <-> 9
+9 <-> 13
+10 <-> 17
+11 <-> 21
diff --git a/testData/src/pkg/TestJADNaming.java b/testData/src/pkg/TestJADNaming.java
new file mode 100644
index 0000000..87e1c03
--- /dev/null
+++ b/testData/src/pkg/TestJADNaming.java
@@ -0,0 +1,12 @@
+package pkg;
+
+import java.io.File;
+
+public class TestJADNaming {
+    public void Func() {
+        int a = 1000, b = 2000, c = 3000, d = 4000;
+        if (a == b || c == d);
+        boolean flag1 = true, flag2 = false, flag3 = true, flag4 = false;
+        if (flag1 == flag2 || flag3 == flag4);
+    }
+}
\ No newline at end of file
-- 
2.10.0.windows.1

